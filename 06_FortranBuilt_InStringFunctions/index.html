<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta name="generator" content="Quarkdown">
    <meta charset="UTF-8">
    <meta name="description" content="a blog demo">
    <meta name="author" content="qinguoming">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="quarkdown:root-path" content="..">
    <title>blog</title>
    <script src="../script/quarkdown.js"></script>
    <script>const capabilities = window.quarkdownCapabilities</script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css" rel="stylesheet">
    <link href="../theme/theme.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.9.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <link href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css" rel="stylesheet">
    <script>capabilities.code = true;</script>
    <style>@font-face { font-family: '-503305824'; src: local('Consolas'); }

body {
    --qd-code-custom-font: '-503305824';
    --qd-main-font-size: 12.0pt;}

body.quarkdown-plain.quarkdown-plain,
body.quarkdown-docs.quarkdown-docs {
}

body.quarkdown-slides.quarkdown-slides .reveal {
}

@page {
    size: auto auto;
    margin: 0;}

p {
}</style>
    <script>prepare(new PlainDocument());</script>
<template id="sidebar-template"><nav class="sidebar" role="doc-toc"><ol><li data-target-id="fortran内置函数-字符串处理部分" data-depth="1"><a href="#fortran内置函数-字符串处理部分">Fortran内置函数-字符串处理部分</a></li></ol></nav>
</template>  </head>
  <body class="quarkdown quarkdown-plain">
    <aside class="margin-area" id="margin-area-left"></aside>
    <main><div class="container fullwidth" style="justify-items: end; text-align: end;"><p><a href="https://qinguoming.pages.dev/">返回 主页</a></p></div><div class="page-break" data-hidden=""></div><h1 id="fortran内置函数-字符串处理部分">Fortran内置函数-字符串处理部分</h1><p>下面列出 Fortran 2008 标准中全部 与字符(CHARACTER)处理有关的 17 个内置函数(intrinsic functions)。  每个都给出 :</p><ul><li>原型(函数头)</li><li>参数表(含类型、意图、可选性)</li><li>返回值</li><li>功能与边界规则</li><li>典型代码</li></ul><p>如无特别说明,所有参数 <span class="codespan-content"><code>STRING</code></span>、<span class="codespan-content"><code>STRING_A</code></span>、<span class="codespan-content"><code>STRING_B</code></span>、<span class="codespan-content"><code>SUBSTRING</code></span>、<span class="codespan-content"><code>SET</code></span>、<span class="codespan-content"><code>C</code></span> 均为任意长度的默认字符型 <span class="codespan-content"><code>character(len=*, kind=1)</code></span>;<br />可选参数 <span class="codespan-content"><code>KIND</code></span> 为整型标量,表示结果字符的 kind;<br />可选参数 <span class="codespan-content"><code>BACK</code></span> 为逻辑型标量,缺省为 <span class="codespan-content"><code>. FALSE.</code></span>。</p><ol><li>LEN(STRING)</li></ol><pre><code class="language-shell">integer function LEN(STRING)
  character(len=*), intent(in) :: STRING</code></pre><ul><li>返回 声明长度(不是当前有效字符数)。</li><li>结果与字符串内容、尾随空格无关。</li></ul><pre><code class="language-shell">character(len=10) :: s = &quot;abc&quot;
print *, LEN(s)        ! 10</code></pre><ol start="2"><li>LEN_TRIM(STRING)</li></ol><pre><code class="language-shell">integer function LEN_TRIM(STRING)
  character(len=*), intent(in) :: STRING</code></pre><ul><li>返回 去掉尾随空格后的有效长度。</li><li>若全为空格,返回 0。</li></ul><pre><code class="language-shell">print *, LEN_TRIM(&quot;FORTRAN   &quot;)   ! 7</code></pre><ol start="3"><li>TRIM(STRING)</li></ol><pre><code class="language-shell">character(len=LEN(STRING)) function TRIM(STRING)
  character(len=*), intent(in) :: STRING</code></pre><ul><li>返回 去掉尾随空格后的子串,长度变为 <span class="codespan-content"><code>LEN_TRIM(STRING)</code></span>。</li><li>结果长度在编译期不可知,只能用于表达式或赋值给自动长度变量。</li></ul><pre><code class="language-shell">write(*,&#39;(a)&#39;) &#39;[&#39;//TRIM(&quot;Hello   &quot;)//&#39;]&#39;   ! [Hello]</code></pre><ol start="4"><li>INDEX(STRING, SUBSTRING [, BACK])</li></ol><pre><code class="language-shell">integer function INDEX(STRING, SUBSTRING, BACK)
  character(len=*), intent(in) :: STRING, SUBSTRING
  logical, optional, intent(in) :: BACK</code></pre><ul><li>返回 SUBSTRING 在 STRING 中首次出现的最左起始位置;<br />若 <span class="codespan-content"><code>BACK=.TRUE.</code></span> 则返回 最右出现位置;<br />未找到返回 0。</li><li>空子串(<span class="codespan-content"><code>SUBSTRING=&quot;&quot;</code></span>)时,返回 1(<span class="codespan-content"><code>BACK=.FALSE.</code></span>)或 <span class="codespan-content"><code>LEN(STRING)+1</code></span>(<span class="codespan-content"><code>BACK=.TRUE.</code></span>)。</li></ul><pre><code class="language-shell">print *, INDEX(&quot;banana&quot;,&quot;an&quot;)          ! 2
print *, INDEX(&quot;banana&quot;,&quot;an&quot;,BACK=.true.) ! 4</code></pre><ol start="5"><li>SCAN(STRING, SET [, BACK])</li></ol><pre><code class="language-shell">integer function SCAN(STRING, SET, BACK)
  character(len=*), intent(in) :: STRING, SET
  logical, optional, intent(in) :: BACK</code></pre><ul><li>返回 STRING 中 第一个(或最后一个,当 <span class="codespan-content"><code>BACK=.TRUE.</code></span>)属于 SET 内任一字符的位置;<br />若都不属于,返回 0。</li></ul><pre><code class="language-shell">print *, SCAN(&quot;FORTRAN&quot;,&quot;AEIOU&quot;)        ! 2 (&#39;O&#39;)
print *, SCAN(&quot;FORTRAN&quot;,&quot;aeiou&quot;,BACK=.true.) ! 0(大小写区分)</code></pre><ol start="6"><li>VERIFY(STRING, SET [, BACK])</li></ol><pre><code class="language-shell">integer function VERIFY(STRING, SET, BACK)
  character(len=*), intent(in) :: STRING, SET
  logical, optional, intent(in) :: BACK</code></pre><ul><li>与 SCAN 相反: 返回 第一个(或最后一个)不在 SET 中的字符位置;<br />若全部都在 SET 中,返回 0。</li></ul><pre><code class="language-shell">print *, VERIFY(&quot;123-45&quot;,&quot;0123456789&quot;)   ! 4(字符 &#39;-&#39;)</code></pre><ol start="7"><li>REPEAT(STRING, NCOPIES)</li></ol><pre><code class="language-shell">character(len=LEN(STRING)*NCOPIES) function REPEAT(STRING, NCOPIES)
  character(len=*), intent(in) :: STRING
  integer, intent(in) :: NCOPIES</code></pre><ul><li>把原串连续复制 <span class="codespan-content"><code>NCOPIES</code></span> 次拼接。</li><li><span class="codespan-content"><code>NCOPIES &lt; 0</code></span> 时返回空串;结果长度可能极大,注意截断。</li></ul><pre><code class="language-shell">print *, REPEAT(&quot;HA&quot;,3)   ! HAHAHA</code></pre><ol start="8"><li>ADJUSTL(STRING)</li></ol><pre><code class="language-shell">character(len=LEN(STRING)) function ADJUSTL(STRING)
  character(len=*), intent(in) :: STRING</code></pre><ul><li>删除前导空格,并在尾部补相同数量空格,实现左对齐。</li></ul><pre><code class="language-shell">print *, &#39;&quot;&#39;//ADJUSTL(&quot;  left&quot;)//&#39;&quot;&#39;   ! &quot;left      &quot;</code></pre><ol start="9"><li>ADJUSTR(STRING)</li></ol><pre><code class="language-shell">character(len=LEN(STRING)) function ADJUSTR(STRING)
  character(len=*), intent(in) :: STRING</code></pre><ul><li>删除尾随空格,并在前面补空格,实现右对齐。</li></ul><pre><code class="language-shell">print *, &#39;&quot;&#39;//ADJUSTR(&quot;right  &quot;)//&#39;&quot;&#39;   ! &quot;     right&quot;</code></pre><ol start="10"><li>CHAR(I [, KIND])</li></ol><pre><code class="language-shell">character(len=1, kind=KIND) function CHAR(I, KIND)
  integer, intent(in) :: I
  integer, optional, intent(in) :: KIND</code></pre><ul><li>返回 处理器字符集中位置 I 的字符(缺省 ASCII)。</li><li>I 越界(&lt;0 或 &gt;127 对于 ASCII)结果由处理器决定。</li></ul><pre><code class="language-shell">print *, CHAR(65)   ! &#39;A&#39;</code></pre><ol start="11"><li>ACHAR(I)</li></ol><pre><code class="language-shell">character(len=1) function ACHAR(I)
  integer, intent(in) :: I</code></pre><ul><li>ASCII 字符集版本 CHAR;保证返回 ASCII 字符。<br />同上。</li></ul><ol start="12"><li>ICHAR&copy;</li></ol><pre><code class="language-shell">integer function ICHAR(C)
  character(len=1), intent(in) :: C</code></pre><ul><li>返回 处理器字符集中 C 的位置(与 CHAR 互逆)。</li></ul><ol start="13"><li>IACHAR&copy;</li></ol><pre><code class="language-shell">integer function IACHAR(C)
  character(len=1), intent(in) :: C</code></pre><ul><li>返回 ASCII 码值(与 ACHAR 互逆)。</li></ul><pre><code class="language-shell">print *, IACHAR(&#39;a&#39;)   ! 97</code></pre><p>14-17. 词汇比较函数<br />LGE(STRING_A, STRING_B)<br />LGT(STRING_A, STRING_B)<br />LLE(STRING_A, STRING_B)<br />LLT(STRING_A, STRING_B)</p><p>原型统一</p><pre><code class="language-shell">logical function L??(STRING_A, STRING_B)
  character(len=*), intent(in) :: STRING_A, STRING_B</code></pre><ul><li>依据 ASCII 顺序 做逐字符比较;大小写敏感。</li><li>返回值含义:   <span class="codespan-content"><code>LGE</code></span>: ≥;<span class="codespan-content"><code>LGT</code></span>: &gt;;<span class="codespan-content"><code>LLE</code></span>: ≤;<span class="codespan-content"><code>LLT</code></span>: &lt;。</li></ul><pre><code class="language-shell">print *, LGT(&quot;apple&quot;,&quot;Apple&quot;)   ! T</code></pre><p>小结速查表</p><table><thead><tr><th>功能类别</th><th>函数名</th></tr></thead><tbody><tr><td>长度</td><td><span class="codespan-content"><code>LEN</code></span>, <span class="codespan-content"><code>LEN_TRIM</code></span></td></tr><tr><td>去空格</td><td><span class="codespan-content"><code>TRIM</code></span>, <span class="codespan-content"><code>ADJUSTL</code></span>, <span class="codespan-content"><code>ADJUSTR</code></span></td></tr><tr><td>查找</td><td><span class="codespan-content"><code>INDEX</code></span>, <span class="codespan-content"><code>SCAN</code></span>, <span class="codespan-content"><code>VERIFY</code></span></td></tr><tr><td>重复</td><td><span class="codespan-content"><code>REPEAT</code></span></td></tr><tr><td>字符 &larr;&gt; 码值</td><td><span class="codespan-content"><code>CHAR</code></span>, <span class="codespan-content"><code>ACHAR</code></span>, <span class="codespan-content"><code>ICHAR</code></span>, <span class="codespan-content"><code>IACHAR</code></span></td></tr><tr><td>词汇比较</td><td><span class="codespan-content"><code>LGE</code></span>, <span class="codespan-content"><code>LGT</code></span>, <span class="codespan-content"><code>LLE</code></span>, <span class="codespan-content"><code>LLT</code></span></td></tr></tbody></table><p>以上 17 个函数全部属于 Fortran 2008 标准 的 intrinsic inquiry/transformational functions,任何合规编译器(gfortran ≥ 4.8、ifort、nvfortran 等)均可直接使用。</p><div class="container fullwidth" style="justify-items: end; text-align: end;"><p><a href="https://qinguoming.pages.dev/">返回 主页</a></p></div></main>
    <aside class="margin-area" id="margin-area-right"></aside>
  </body>
</html>
